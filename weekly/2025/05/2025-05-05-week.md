# 🗓️ 2025 年 05 月 05 日（月）学習ログ（Selinger 論文：セクション 4）

## ✅ 学習概要

- Selinger らによる論文「Access Path Selection in a Relational Database Management System」を読んだ。
- 本日はセクション 4 までを精読し、単一テーブルのアクセスパスの経路選択について学んだ。

---

## 🕰️ 学習時間

150 分

---

## 📚 使用教材

- Selinger, P. Griffiths et al., Access Path Selection in a Relational Database Management System, 1979（提供 PDF）

---

## 📖 学習範囲・内容

- COST = PAGE FETCHES + W + RSI CALLS
- W: I/O と CPU 間の調整可能な重み付け係数
- RSI CALLS: RSS から返される予測タプル数（CPU 時間の近似値）
- クエリを処理するための最小コストの経路選択 ≒ 必要な総リソースを最小化するもの
- 述語が SARGABLE かつ、列が INDEX の初期部分文字列 ⇒ INDEX アクセスパスにマッチする
- 統計情報はユーザによって周期的に更新される（自動的に更新はされない）
- ORDER BY や GROUP BY がない場合は、"interesting" でない順序で最も安いアクセスパスが選択される
- ORDER BY や GROUP BY がある場合は、MIN("interesting" な順序, "unordered" な順序)でアクセスパスが選択される

### 📊 統計情報

| 語句     | 説明                                   |
| :------- | :------------------------------------- |
| NCARD(T) | カーディナリティ                       |
| TCARD(T) | タプルを保持するセグメント間のページ数 |
| P(T)     | セグメント間のデータページの割合       |
| ICARD(T) | インデックスの異なるキーの数           |
| NINDX(T) | インデックスのページ数                 |
| QCARD    | Query Cardinality                      |

※ P(T) = TCARD(T) / (no. of non-empty pages in the segment)
※ QCARD = クエリブロックの FROM リストに含まれるすべてのリレーションのカーディナリティ × クエリブロックの boolean 因子のすべての選択性因子

### 📐 COST FORMULAS 一覧

| アクセスパス種別                   | コスト式                                          | 説明                                                             |
| :--------------------------------- | :------------------------------------------------ | :--------------------------------------------------------------- |
| セグメントスキャン（全件スキャン） | COST = NCARD                                      | 全ページを読み込むコスト。SARG がなければ全件対象。              |
| セグメントスキャン + SARG          | COST = NCARD × F                                  | セレクティビティ F により必要なページ数を減らす。                |
| インデックススキャン               | COST = #index page fetches + #data page fetches   | インデックス走査 + 実データ読み出しの合計。B-tree の高さも考慮。 |
| インデックススキャン + SARG        | COST = ICOST + DPCOST × F                         | ICOST: インデックスページ数, DPCOST: データページ数。            |
| タプル単位の CPU コスト            | + W × (TCARD × F)                                 | RSI CALLS の部分に対応。タプルごとの処理時間の見積もり。         |
| 複合述語（AND/OR）                 | F = F1 \* F2（AND）, F = F1 + F2 - F1 \* F2（OR） | 論理演算に基づく合成。                                           |
| NOT 述語                           | F = 1 - F1                                        | 補集合としての計算。                                             |

### 💡 補足キーワード

| 用語     | 意味                                                                                     |
| :------- | :--------------------------------------------------------------------------------------- |
| F        | 選択性（Selectivity Factor）。条件を満たす割合。                                         |
| RSS      | Relational Storage System：物理的記憶構造（テーブル・インデックス等）を操作する層。      |
| RSI      | Relational Storage Interface：RSS への呼び出しインターフェース。上位のエンジンから使用。 |
| sargable | Search ARGument applicable。スキャン中に事前適用可能な述語。                             |
| ICARD    | インデックスのユニークキー数。1 / ICARD が等価述語の選択性になる。                       |
| W        | I/O と CPU のバランスを調整する重み係数。経験則により調整可能。                          |

（以下、SELECTIVITY FACTORS と調べた単語・用語〜は続きとしてそのまま残す）

### 計算式 (SELECTIVITY FACTORS)

※ F = 選択性因子（条件を満たすタプルの割合）

#### 1. column = value

インデックス列の場合

```math
F = 1 / ICARD(column index)
```

それ以外

```math
F = 1 / 10
```

→ これは統計がない場合の約束値（arbitrary value）として読み取れる

#### 2. column1 = column2

両方がインデックス列：

```math
F = 1 / MAX(ICARD(column1 index), ICARD(column2 index))
```

片方だけインデックス列：

```math
F = 1 / ICARD(column-i index)
```

それ以外：

```math
F = 1 / 10
```

#### 3. column > value

算術型の場合：

```math
F = (high key value - value) / (high key value - low key value)
```

それ以外：

```math
F = 1 / 3
```

#### 4. column BETWEEN value1 AND value2

算術型＆両値が明示の場合：

```math
F = (value2 - value1) / (high key value - low key value)
```

それ以外：

```math
F = 1 / 4
```

#### 5. column IN (list of values)

```math
F = min(リスト個数 × (F の件), 1/2)
```

#### 6. column A IN subquery

```math
F = (サブクエリ結果の予測カーディナリティ) / (すべてのFROMリストのカーディナリティの積)
```

#### 7. 論理演算による合成

| 演算 | 計算式                  |
| :--- | :---------------------- |
| AND  | `F = F1 * F2`           |
| OR   | `F = F1 + F2 - F1 * F2` |
| NOT  | `F = 1 - F1`            |

---

## 📗 調べた単語・用語

| 単語          | 意味                                                                              |
| :------------ | :-------------------------------------------------------------------------------- |
| conjunctive   | 接続の                                                                            |
| notable       | 注目すべき                                                                        |
| retrieve      | 取得する                                                                          |
| periodically  | 周期的に                                                                          |
| correspond    | 対応する                                                                          |
| imply         | 暗示する                                                                          |
| arbitrary     | 任意                                                                              |
| interpolation | 補完                                                                              |
| significance  | 意義                                                                              |
| derive        | 導く                                                                              |
| RSS           | Relational Storage System: 物理的な記憶構造を管理する層                           |
| RSI           | Relational Storage Interface: オプティマイザが RSS に呼び出すためのインタフェース |
| sargable      | 条件をスキャン時に適用できるもの（例：col = value）                               |

---

## 📊 疑問点と確認結果

| 項目                | 疑問                                                               | メモ・確認ポイント                                                                                                |
| :------------------ | :----------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- |
| SELECTIVITY FACTORS | high key value と low key value のところがイメージできない         | 実際のデータ分布や範囲値がないと描きにくいが、それに基づいた統計評価を行う主旋の計算式として表現される            |
| SELECTIVITY FACTORS | BETWEEN などに出てくる算術型って、文字列の時は該当しないってこと？ | その通りにゃ！算術型は数値分布を前提としているので、文字列の場合はデフォルト値 (1/3 や 1/4)での複合が使われる     |
| SELECTIVITY FACTORS | Subquery のところがイメージできない                                | どれだけの行がサブクエリ結果に含まれるかを予測し、合理的な選択性を予測する。例：サブクエリ結果 / リレーション総数 |

---

## 💬 感想・気づき

- アクセスパスの経路決定に関するところは内部実装依存で普段あまり意識しないので、どういう計算をしているのかわかってよかった、JOIN などはよりパフォーマンスに影響出てくるところなのでしっかり学習したい
- やっぱり英語読む力が欠けているから、かなり時間がかかってしまうので別途学習が必要
- コスト計算について学び終えた際はこれをどう実業務でいかしていくかを検討したい
