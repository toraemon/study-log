# 🗓️ 2025 年 05 月 05 日（月）学習ログ（Selinger 論文：セクション 4）

## ✅ 学習概要

- Selinger らによる論文「Access Path Selection in a Relational Database Management System」を読んだ。
- 本日はセクション 4 までを精読し、単一テーブルのアクセスパスの経路選択について学んだ。

---

## 🕰️ 学習時間

150 分

---

## 📚 使用教材

- Selinger, P. Griffiths et al., Access Path Selection in a Relational Database Management System, 1979（提供 PDF）

---

## 📖 学習範囲・内容

- COST = PAGE FETCHES + W + RSI CALLS
- W: I/O と CPU 間の調整可能な重み付け係数
- RSI CALLS: RSS から返される予測タプル数（CPU 時間の近似値）
- クエリを処理するための最小コストの経路選択 ≒ 必要な総リソースを最小化するもの
- 述語が SARGABLE かつ、列が INDEX の初期部分文字列 ⇒ INDEX アクセスパスにマッチする
- 統計情報はユーザによって周期的に更新される（自動的に更新はされない）
- ORDER BY や GROUP BY がない場合は、"interesting" でない順序で最も安いアクセスパスが選択される
- ORDER BY や GROUP BY がある場合は、MIN("interesting" な順序, "unordered" な順序)でアクセスパスが選択される

### 📊 統計情報

| 語句     | 説明                                   |
| :------- | :------------------------------------- |
| NCARD(T) | カーディナリティ                       |
| TCARD(T) | タプルを保持するセグメント間のページ数 |
| P(T)     | セグメント間のデータページの割合       |
| ICARD(T) | インデックスの異なるキーの数           |
| NINDX(T) | インデックスのページ数                 |
| QCARD    | Query Cardinality                      |

※ P(T) = TCARD(T) / (no. of non-empty pages in the segment)
※ QCARD = クエリブロックの FROM リストに含まれるすべてのリレーションのカーディナリティ × クエリブロックの boolean 因子のすべての選択性因子

### 📐 COST FORMULAS 一覧

| アクセスパス種別                   | コスト式                                          | 説明                                                             |
| :--------------------------------- | :------------------------------------------------ | :--------------------------------------------------------------- |
| セグメントスキャン（全件スキャン） | COST = NCARD                                      | 全ページを読み込むコスト。SARG がなければ全件対象。              |
| セグメントスキャン + SARG          | COST = NCARD × F                                  | セレクティビティ F により必要なページ数を減らす。                |
| インデックススキャン               | COST = #index page fetches + #data page fetches   | インデックス走査 + 実データ読み出しの合計。B-tree の高さも考慮。 |
| インデックススキャン + SARG        | COST = ICOST + DPCOST × F                         | ICOST: インデックスページ数, DPCOST: データページ数。            |
| タプル単位の CPU コスト            | + W × (TCARD × F)                                 | RSI CALLS の部分に対応。タプルごとの処理時間の見積もり。         |
| 複合述語（AND/OR）                 | F = F1 \* F2（AND）, F = F1 + F2 - F1 \* F2（OR） | 論理演算に基づく合成。                                           |
| NOT 述語                           | F = 1 - F1                                        | 補集合としての計算。                                             |

### 💡 補足キーワード

| 用語     | 意味                                                                                     |
| :------- | :--------------------------------------------------------------------------------------- |
| F        | 選択性（Selectivity Factor）。条件を満たす割合。                                         |
| RSS      | Relational Storage System：物理的記憶構造（テーブル・インデックス等）を操作する層。      |
| RSI      | Relational Storage Interface：RSS への呼び出しインターフェース。上位のエンジンから使用。 |
| sargable | Search ARGument applicable。スキャン中に事前適用可能な述語。                             |
| ICARD    | インデックスのユニークキー数。1 / ICARD が等価述語の選択性になる。                       |
| W        | I/O と CPU のバランスを調整する重み係数。経験則により調整可能。                          |

（以下、SELECTIVITY FACTORS と調べた単語・用語〜は続きとしてそのまま残す）

### 計算式 (SELECTIVITY FACTORS)

※ F = 選択性因子（条件を満たすタプルの割合）

#### 1. column = value

インデックス列の場合

```math
F = 1 / ICARD(column index)
```

それ以外

```math
F = 1 / 10
```

→ これは統計がない場合の約束値（arbitrary value）として読み取れる

#### 2. column1 = column2

両方がインデックス列：

```math
F = 1 / MAX(ICARD(column1 index), ICARD(column2 index))
```

片方だけインデックス列：

```math
F = 1 / ICARD(column-i index)
```

それ以外：

```math
F = 1 / 10
```

#### 3. column > value

算術型の場合：

```math
F = (high key value - value) / (high key value - low key value)
```

それ以外：

```math
F = 1 / 3
```

#### 4. column BETWEEN value1 AND value2

算術型＆両値が明示の場合：

```math
F = (value2 - value1) / (high key value - low key value)
```

それ以外：

```math
F = 1 / 4
```

#### 5. column IN (list of values)

```math
F = min(リスト個数 × (F の件), 1/2)
```

#### 6. column A IN subquery

```math
F = (サブクエリ結果の予測カーディナリティ) / (すべてのFROMリストのカーディナリティの積)
```

#### 7. 論理演算による合成

| 演算 | 計算式                  |
| :--- | :---------------------- |
| AND  | `F = F1 * F2`           |
| OR   | `F = F1 + F2 - F1 * F2` |
| NOT  | `F = 1 - F1`            |

---

## 📗 調べた単語・用語

| 単語          | 意味                                                                              |
| :------------ | :-------------------------------------------------------------------------------- |
| conjunctive   | 接続の                                                                            |
| notable       | 注目すべき                                                                        |
| retrieve      | 取得する                                                                          |
| periodically  | 周期的に                                                                          |
| correspond    | 対応する                                                                          |
| imply         | 暗示する                                                                          |
| arbitrary     | 任意                                                                              |
| interpolation | 補完                                                                              |
| significance  | 意義                                                                              |
| derive        | 導く                                                                              |
| RSS           | Relational Storage System: 物理的な記憶構造を管理する層                           |
| RSI           | Relational Storage Interface: オプティマイザが RSS に呼び出すためのインタフェース |
| sargable      | 条件をスキャン時に適用できるもの（例：col = value）                               |

---

## 📊 疑問点と確認結果

| 項目                | 疑問                                                               | メモ・確認ポイント                                                                                                |
| :------------------ | :----------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- |
| SELECTIVITY FACTORS | high key value と low key value のところがイメージできない         | 実際のデータ分布や範囲値がないと描きにくいが、それに基づいた統計評価を行う主旋の計算式として表現される            |
| SELECTIVITY FACTORS | BETWEEN などに出てくる算術型って、文字列の時は該当しないってこと？ | その通りにゃ！算術型は数値分布を前提としているので、文字列の場合はデフォルト値 (1/3 や 1/4)での複合が使われる     |
| SELECTIVITY FACTORS | Subquery のところがイメージできない                                | どれだけの行がサブクエリ結果に含まれるかを予測し、合理的な選択性を予測する。例：サブクエリ結果 / リレーション総数 |

---

## 💬 感想・気づき

- アクセスパスの経路決定に関するところは内部実装依存で普段あまり意識しないので、どういう計算をしているのかわかってよかった、JOIN などはよりパフォーマンスに影響出てくるところなのでしっかり学習したい
- やっぱり英語読む力が欠けているから、かなり時間がかかってしまうので別途学習が必要
- コスト計算について学び終えた際はこれをどう実業務でいかしていくかを検討したい

---

# 🗓️ 2025年05月07日（水）学習ログ（WebAPI:TheGoodParts：3章）

## ✅ 学習概要

- 要点
  - [Good] HTTPの仕様を最大限利用し、独自仕様の利用を最低限にとどめる
  - [Good] 適切なステータスコードを用いる
  - [Good] 適切な、なるべく一般的なメディアタイプを返す
  - [Good] クライアントが適切なキャッシュを行えるように情報を返す

---

## ⏱ 学習時間
30分

---

## 📚 使用教材

- 『Web API: The Good Parts』（第 4 章）

---

## 📖 学習範囲・内容

- レスポンスステータスコードは200番代（成功）、400番代（クライアントサイドに起因するエラー）、500番代（サーバサイドに起因するエラー）
- キャッシュ戦略はExpirationModel（期限切れモデル）、ValidationModel（検証モデル）、HeuristicExpiration（発見的期限切れ）、キャッシュさせないがある

---

## 📊 疑問点と確認結果

| 疑問 | ゴエモン（ChatGPT）回答 |
| :--- | :--- |
| ①押さえておくべきステータスコードは？ | 基本的には今使っているものでOK |
| ②押さえておくべきキャッシュディレクティブは？ | 下記参照 |
| ③押さえておくべきメディアタイプは？ | 下記参照 |

### ①押さえておくべきステータスコード
| ステータスコード | 説明 |
| :--- | :--- |
| 200 | OK：成功。通常のGETやPUTの成功時。 |
| 201 | Created：POSTで新規リソース作成時に使うべき。|
| 204 | No Content：成功したけど返すべきデータがない場合（DELETEや一部のPUT）。|
| 400 | Bad Request：リクエスト内容がおかしい（バリデーションエラーなど）。|
| 401 | Unauthorized：認証が必要なのに行われていない。|
| 403 | Forbidden：認証済みだが、権限がない。|
| 404 | Not Found：リソースが存在しない。|
| 409 | Conflict：リソースの状態によって衝突が起きた（例：重複登録など）。|
| 500 | Internal Server Error：サーバー内の予期しないエラー。|
| 503 | Service Unavailable：サービス一時停止中、メンテナンス中など。|

**✅ 検討したい追加候補**

| ステータスコード | 説明 |
| :--- | :--- |
| 422 | Unprocessable Entity：バリデーションエラーなどを明示したいときに400より具体的 |
| 429 | Too Many Requests：レートリミット（認証試行やAPIアクセス制限）を導入している場合に。 |

### ②押さえておくべきキャッシュディレクティブ
| ディレクティブ | 説明 |
| :--- | :--- |
| no-store | **一切キャッシュさせない**（認証情報など機密データ向け）。 |
| no-cache | **キャッシュするけど毎回再検証が必要。** |
| max-age=N | **キャッシュの有効期間（秒）**。例：max-age=3600 |
| must-revalidate | 有効期限が切れたら再検証必須。 |
| private | クライアント単位でのみキャッシュ。共有キャッシュ（CDNなど）不可。 |
| public | どこでもキャッシュ可能。 |

📌トークンやユーザー情報APIは「no-store + 認証あり」パターンが基本

### ③メディアタイプ：JSON以外に覚えておきたいもの
| メディアタイプ | 用途例 |
| :--- | :--- |
| application/xml | レガシーAPI対応や外部サービスとの連携（減少傾向） |
| application/x-www-form-urlencoded | フォームデータ送信（古典的POST） |
| multipart/form-data | ファイルアップロード（画像・音声など） |
| application/problem+json | RFC7807 形式のエラー詳細表現 |
| text/csv | CSVダウンロードAPIなど |
| application/pdf や image/webp など | バイナリファイル提供 |

---

## 🐾 Web API 第4章 理解チェック問題（4問）

### 問題1：ステータスコードの適切な使い分け
以下のAPIのレスポンスとして最も適切なHTTPステータスコードを選びなさい。

「ユーザー情報を更新するPUT API」で、更新対象のユーザーが存在しなかった場合」

A. 200 OK  
B. 204 No Content  
C. 404 Not Found  
D. 409 Conflict

### 問題2：キャッシュ制御に関する理解
以下のうち、一切キャッシュをさせたくない場合に最も適切な Cache-Control のディレクティブはどれか？

A. no-cache  
B. no-store  
C. private  
D. must-revalidate

### 問題3：メディアタイプの選択
ファイルアップロードを伴うフォームデータ送信に最適なメディアタイプはどれか？

A. application/json  
B. application/x-www-form-urlencoded  
C. multipart/form-data  
D. application/octet-stream  

### 問題4：ステータスコードの区別
次のうち、認証はされているが、その操作を行う権限がないときに返すべきステータスコードはどれか？

A. 401 Unauthorized  
B. 403 Forbidden  
C. 404 Not Found  
D. 422 Unprocessable Entity

---

## 🐾 Web API 第4章：理解チェック問題と解説

### ✅ 問題1：ステータスコードの使い分け
Q. ユーザー情報を更新するPUT APIで、更新対象のユーザーが存在しなかった場合に返すべきステータスコードは？  
A. C. 404 Not Found

### 📝 解説：
リソースが存在しないことを明示する場合は 404。
排他制御（バージョン不一致や二重更新）などの場合は 409 Conflict を使うが、今回のケースは「対象が存在しない」ため 404 が適切。

### ✅ 問題2：キャッシュ制御
Q. 一切キャッシュをさせたくない場合に適切な Cache-Control ディレクティブは？  
A. B. no-store

### 📝 解説：

no-store：キャッシュに保存すらしない（機密情報に使用）。

no-cache：キャッシュに保存してよいが、使用前にサーバーへ再検証が必要。

### ✅ 問題3：メディアタイプ
Q. ファイルアップロードを伴うフォームデータ送信で使うべきメディアタイプは？  
A. C. multipart/form-data

### 📝 解説：
ファイルとテキストデータを同時に送信する場合の標準的な形式。HTMLフォームで enctype="multipart/form-data" を指定するケースでも使われる。

### ✅ 問題4：ステータスコードの違い
Q. 認証はされているが、操作の権限がない場合に返すべきステータスコードは？  
A. B. 403 Forbidden

### 📝 解説：

401 Unauthorized：認証がされていない。

403 Forbidden：認証済みだが許可されていない操作（例：一般ユーザーが管理者APIを叩いたなど）。

---

## 💬 感想・気づき

- レスポンスステータスは基本的には調べながらAPIを設計していたので、ある程度は押さえられていたけどPUT（PATCH）を200にするか204にするかの基準がわかってよかった
- やっぱり2014年出版ということもあってCORSやWebPなどがまだ広がる前なのかなと感じる記載がところどころ見られる、最新版になると結構変わったりするのかなぁ？
- キャッシュのディレクティブについては結構いい加減な理解だったので改めて学習する機会となったけど、まだ表面上の理解しかできていないのでどこかのタイミングで実際に挙動を確認しながら理解を深めたい

---

## 📕 参考文献（ある場合だけ）

- 教科書関連
- 関連文献
