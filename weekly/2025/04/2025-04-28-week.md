# 🗓️ 2025年04月28日（月）学習ログ（Selinger論文：セクション2〜セクション3）

## ✅ 学習概要

- Selingerらによる論文「Access Path Selection in a Relational Database Management System」を読んだ。
- 本日はイントロダクション〜セクション3までを精読し、SQL処理の流れとアクセスパス（スキャン方法）について学んだ。
- 内容の定着を確認するため、ゴエモン作成の簡易理解度チェック問題にも取り組んだ。

## 🕰️ 学習時間
90分

---

## 📚 使用教材

- Selinger, P. Griffiths et al., *Access Path Selection in a Relational Database Management System*, 1979（提供PDF）
- ゴエモン作成の理解度チェック問題

---

## 📖 学習範囲・内容

- **SQL処理の4段階プロセス**（Parsing → Optimization → Code Generation → Execution）
- **オプティマイザの役割**
  - 参照テーブル・カラムの存在チェック
  - 統計情報の取得
  - アクセスパス選択（トータルコスト最小化）
- **ストレージアクセスの種類**
  - セグメントスキャン（フルスキャン）
  - インデックススキャン（範囲・部分取得）
- **インデックスの構造**
  - B-treeベースで実装され、クラスタリングされているとアクセス効率が向上
- **SARG（Search Argument）**
  - "カラム = 値"のような単純な比較式をスキャン時に事前適用できることでコスト削減
- **理解度チェック問題での総合確認**
  - 全問正解、重要概念を正しく整理できた

---

## 📊 疑問点と確認結果

| 項目 | 疑問 | メモ・確認ポイント |
| :--- | :--- | :--- |
| SARGとは何か？ | どこに記載がある？ | Section 3中盤に記載あり。スキャン前に適用可能な単純比較条件（col = value など）を指す。 |
| クラスタードインデックスのメリット | なぜアクセスコストが下がる？ | データが物理的にもインデックス順に近く並び、範囲アクセス時にI/O効率が上がるため。 |

---

## 📝 復習問題と回答

### 【問題1】
**System RでSQL文を処理するときの基本的な4つのステップは何か、順番に答えてにゃ。**

**回答:**  
Parsing → Optimization → Code Generation → Execution

---

### 【問題2】
**System Rのオプティマイザの役割を次から選んでにゃ。**

- A. 文法エラーを検出する  
- B. 最小コストのアクセスパスを選択する  
- C. SQL文をマシン語に翻訳する  
- D. 物理ページのI/O制御を行う

**回答:**  
B. 最小コストのアクセスパスを選択する

---

### 【問題3】
**セグメントスキャンとは何をする操作か、次から選んでにゃ。**

- A. インデックスを使って特定のデータだけを取り出す  
- B. テーブルの全データ（全ページ）を順番に読みながら必要な行を取り出す  
- C. データを並び替えてからアクセスする  
- D. 複数テーブルを結合する操作を始める

**回答:**  
B. テーブルの全データを順番に読む

---

### 【問題4】
**インデックススキャンに関して、正しい説明を次から選んでにゃ。**

- A. 必ずテーブル全体をなめる必要がある  
- B. インデックスをたどって、特定の範囲や特定の値のデータだけを効率的に取得できる  
- C. インデックススキャンでは、データページにアクセスする必要はない  
- D. インデックススキャンはクラスタリングされていないと絶対に使えない

**回答:**  
B. インデックスをたどって、特定の範囲や値を効率的に取得できる

---

### 【問題5】
**Search Argument（SARG）にできる条件はどれにゃ？**

- A. `col1 = 100`  
- B. `col2 LIKE '%abc%'`  
- C. `col3 BETWEEN 10 AND 20`  
- D. `col4 IS NULL`

**回答:**  
A. `col1 = 100`

---

### 【ボーナス問題】
**クラスタードインデックスがあるとき、なぜアクセスコストが下がるか？**

**回答:**  
B-treeで物理的にもデータがインデックス順に近く並んでいるため、範囲検索時に1回のI/Oで多くのデータを取得でき、ページアクセス回数が減るためアクセスコストが下がる。

---

## 💬 感想・気づき

- 英語論文を読むのは大変だったが、キーワードと要点を先に押さえてから読むことで理解しやすくなった。
- SQL処理の4段階（パース→最適化→コード生成→実行）の流れが頭に入ったことで、オプティマイザの位置づけが明確に理解できた。
- インデックススキャンやセグメントスキャンの仕組み、特にクラスタリングの影響について、実務でも活かせそうな知識を得られた。
- Section4以降はコスト推定や動的計画法が登場するため、さらに集中して取り組む必要があると感じた。

---

## 📕 参考文献（ある場合だけ）

- Selinger, P. Griffiths et al., *Access Path Selection in a Relational Database Management System*, 1979.

---

# 🗓️ 2025年04月30日（水）学習ログ（WebAPI:TheGoodParts：3章）

## ✅ 学習概要

- 要点
  　　- [Good] JSON、あるいは目的に応じたデータ形式を採用する
  　　- [Good] データを不要なエンベロープで包まない
  　　- [Good] レスポンスをできる限りフラットな構造にする
  　　- [Good] 各データの名前が簡潔で理解しやすく、適切な単数複数が用いられている
  　　- [Good] エラーの形式を統一し、クライアント側でエラー詳細を機械的に理解可能にする
- 『Web API: The Good Parts』第 3 章「レスポンスデータの設計」を読了
- API のレスポンス設計と実務での設計を振り返りながら、設計視点の学びを深めた

---

## 📚 使用教材

- 『Web API: The Good Parts』（第 3 章）

---

## 📖 学習範囲・内容

- データフォーマットは現在 JSON が主流、それ以外はオプション
- レスポンスはなるべくフラット、どうしても階層化した方がいい場合は階層化する
- 配列とフォーマットでレスポンス全体をオブジェクトにすることでセキュリティ上のリスクを避けることができる

---

## 📊 疑問点と確認結果

| 疑問                                                                                     | メモ・確認ポイント                                 |
| :--------------------------------------------------------------------------------------- | :------------------------------------------------- |
| ① スネークケースの優位性が知りたい、現在も変わらず？                                     | 明確な差はなさげ、言語に応じた形に落ち着いている？ |
| ② レスポンスの配列をオブジェクトで包むセキュリティ上のメリットがいまいち理解できなかった |   JSONインジェクションを防ぐため                                                 |

### ゴエモン（ChatGPT の回答）

### ① スネークケースの優位性が知りたい、現在も変わらず？

これは**「統計的な決定打はないけど、文化や傾向としてはある」**って感じにゃ！

🔹 **客観的なデータは…？**  
論文や大規模な調査で「snake_case の方が優れている」と断定したものは特にないにゃ。

ただ、以下のような背景で「良いとされやすい」風潮はあるにゃ：

| 背景         | 内容                                                                    |
| ------------ | ----------------------------------------------------------------------- |
| DB 由来      | RDB では user_name のようなスネークが定番で、API でもそのまま使うと自然 |
| 多言語対応   | Python/Ruby/C 系などで snake_case 文化がある言語と連携しやすい          |
| 可読性重視派 | 「単語の区切りが視覚的に分かりやすい」と感じる人が一定数いるにゃ        |

でも、Java → TypeScript といった開発経験の流れだと、camelCase が主流になるにゃ！

✅ **まとめ**  
snake_case が「ポジティブ」というより、**「場面によって自然な選択」**って感じに

#### ② レスポンスの配列をオブジェクトで包むセキュリティ上のメリットがいまいち理解できなかった

ここがちょっと難しめで、でも超大事なポイントにゃ！

🔥 **なぜ JSON 配列だけを返すとセキュリティ上リスクがあるの？**  
それは「JSON インジェクション攻撃」と呼ばれる脆弱性に関係してるにゃ。

💥 **JSON インジェクションとは？**  
JSON として返すべきデータが JavaScript として解釈されて実行されてしまうケースにゃ

特に、application/json が正しく指定されていない、古いブラウザでは、

```
["foo", "bar"]
```

というレスポンスが スクリプト扱いされてしまうことがあるにゃ！

👿 **実際の攻撃例（昔の IE など）**

```
<script src="https://example.com/api/users"></script>
```

このとき、API のレスポンスが ["admin", "user"] みたいな素の配列だけだと、
ブラウザが 「これは JS コードだ！」 と誤解して実行されちゃうことがあるにゃ…！

✅ **だから防ぐ方法としては**：  
JSON のトップレベルは必ずオブジェクトにする

```
{
"users": ["admin", "user"]
}
```
これなら「ただのオブジェクトだから JS 実行じゃないよね」ってちゃんと解釈されるにゃ！

✅ **補足にゃ**  
現代のブラウザやライブラリ（fetch, axios など）ではこの問題はかなり減ってる

でも、「REST API 設計の防御的スタンス」として今もベストプラクティスにゃ！

✨ **まとめにゃ！**

| ポイント | 内容 |
| ------- | ---- |
| スネークケース | 客観データは少ないが、文化的な選好や連携性で使われるにゃ |
| JSON 配列のラップ | 昔のブラウザで JS として実行されるリスクを防ぐため |
→ オブジェクトで包もう！ は防御設計の基本にゃ

---

## 💬 感想・気づき

- レスポンス設計はフラット構造＋一貫性が大事
- JSON の台頭と XML の歴史的な流れが Google トレンドで見えて面白かった
- JSONP はセキュリティ上の課題もあり、今では基本使われない
- 実務でも S3・Next.js で CORS 設定を経験済みで、理論と現場のつながりを感じた
- 色々な外部公開されている API を見て設計を学びたい

---

## 📕 参考文献（ある場合だけ）

- 教科書関連
- 関連文献

